#include <avr/power.h>

#define PB2 2  // Pin 10
#define PB3 3  // Pin 11

#define N_PORTS 1   // How many square signal you generate. Set as 1 to generating 40 kHz signal. / 2 to 80kHz / 3 to 120kHz... (But there is many overlap at over than 1 so DO NOT CHANGE)
#define N_BUTTONS 5 // How many external interrupt switch we use? (5 is PB2 ~ PB7 (0 to 5) / Digital pin 2 ~ pin 7)
#define N_DIVS 24   // 24 columns for animation array 
#define N_FRAMES 29 // 29 rows for animation array

// Because we cannot use delay function by using external interrupt, write many no-operation to generate the time delay 
// WAIT_LOT : 14 nop
#define WAIT_LOT(a) __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");__asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");__asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");__asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop")
// WAIT_MID : 13 nop
#define WAIT_MID(a) __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");__asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");__asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop")
// WAIT_LIT : 9 nop
#define WAIT_LIT(a) __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop");  __asm__ __volatile__ ("nop")

// Main function of Ultrasound_Operator / Based on pointer knowledge
#define OUTPUT_WAVE(pointer, d)  PORTC = pointer[d*N_PORTS + 0]


#define BUTTON_SENS 5000 // Sensitivity of Push button. If lower number in it, push button will be really sensitive.

static byte frame = 19; // THIS number means the START phase.
static byte animation[N_FRAMES][N_DIVS] = 
{{0x6,0xc,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x3,0x3,0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6}, // 0th frame
//0110 1100 1100 1100 1100 1100 1001 1001 1001 1001 1001 1001 1001 0011 0011 0011 0011 0011 0110 0110 0110 0110 0110 0110
{0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x3,0x3,0x3,0x6,0x6,0x6},
//0110 0110 0110 0110 0110 1100 1100 1100 1100 1001 1001 1001 1001 1001 1001 1001 1001 0011 0011 0011 0011 0110 0110 0110
{0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x3,0x3},
//0110 0110 0110 0110 0110 0110 0110 0110 0110 1100 1100 1100 1001 1001 1001 1001 1001 1001 1001 1001 1001 0011 0011 0011
{0x3,0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9},
//0011 0011 0011 0110 0110 0110 0110 0110 0110 0110 0110 0110 1100 1100 1100 1001 1001 1001 1001 1001 1001 1001 1001 1001
{0x9,0x9,0x9,0x9,0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9},
//1001 1001 1001 1001 0011 0011 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1100 1100 1001 1001 1001 1001 1001 1001
{0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0x9,0x9,0x9},
{0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc},
{0x6,0x6,0x6,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6},
{0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0xc,0x6,0x6,0x6,0x6,0x6},
{0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0xc,0x6,0x6},
{0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x3,0x3,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0xc},
{0x9,0x9,0xc,0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x3,0x3,0x9,0x9,0x9,0x9,0x9,0x9,0x9},
{0x9,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x3,0x3,0x3,0x9,0x9,0x9,0x9},
{0x9,0x9,0x9,0x9,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x3,0x3,0x3,0x3},
{0x3,0x3,0x3,0x9,0x9,0x9,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x3,0x3},
{0x3,0x3,0x3,0x3,0x3,0x3,0x9,0x9,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x6,0x6,0x6,0x6,0x6,0x3},
{0x6,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x6,0x6},
{0xc,0x6,0x6,0x6,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x9,0x9,0x9,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc},
{0xc,0xc,0xc,0xc,0x6,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x9,0xc,0xc,0xc,0xc,0xc,0xc,0xc}, 
{0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0xc,0xc,0xc,0xc,0xc}, //19th frame (start phase / up shift to 0th / down shift to 29)
{0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x9,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x6,0xc,0xc},
{0x6,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x6,0x6},
{0x6,0x6,0x6,0x6,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3},
{0x3,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x3,0x3,0x3,0x3,0x3,0x3},
{0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3,0x3,0x3},
{0x3,0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x3},
{0x9,0x9,0x3,0x3,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0xc,0xc,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9},
{0x9,0x9,0x9,0x9,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x9,0x9,0x9,0x9,0x9,0x9,0x9,0x9},
{0x9,0x9,0x9,0x9,0x9,0xc,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x6,0x3,0x9,0x9,0x9,0x9,0x9,0x9}}; //28th frame
// Phase information for each transducers.

void setup()
{
  DDRC = 0b00111111; //A0 to A5 are the signal outputs
  PORTC = 0b00000000; 
   
  DDRB |= (1 << PB2); //pin 10 (B2) will generate a 40kHz signal to sync / pinMode(10, OUTPUT);
  DDRB &= ~(1 << PB3); //pin 11 (B3) is the sync in / pinMode(11, INPUT_PULLUP);
  //please connect pin 10 to pin 11

  for (int i = 2; i < 8; ++i){ //pin 2 to 7 (D2 to D7) are inputs for the buttons
    DDRD &= ~(1 << i); // Clear the i_th bit of DDRD to set as input
    PORTD |= (1 << i); // Set the i_th bit of PORTD to enable pull-up
    // pinMode(i, INPUT_PULLUP); 
  }

  // generate a sync signal of 40khz in pin 10
  noInterrupts();           // disable all interrupts
  TCCR1A = bit (WGM10) | bit (WGM11) | bit (COM1B1); // fast PWM, clear OC1B on compare
  TCCR1B = bit (WGM12) | bit (WGM13) | bit (CS10);   // fast PWM, no prescaler
  OCR1A =  (F_CPU / 40000L) - 1;
  OCR1B = (F_CPU / 40000L) / 2;
  interrupts();             // enable all interrupts

  // disable everything that we do not need 
  ADCSRA = 0;  // ADC
  power_adc_disable ();
  power_spi_disable();
  power_twi_disable();
  power_timer0_disable();
  power_usart0_disable();

 byte* emittingPointer = &animation[frame][0]; //It means the pointer, static byte frame = 19; / & : address of operator
 byte buttonsPort = 0;

 bool anyButtonPressed;
 bool buttonPressed[N_BUTTONS]; // N_BUTTONS = 5 means PD2 to PD7, Sensing the button action of DDRD (for extra external switch)
 short buttonCounter = 0;

  LOOP:
    while(PINB & 0b00001000); //wait for pin 11 (B3) to go low 
    // #define OUTPUT_WAVE(pointer, d)  PORTC = pointer[d*N_PORTS + 0] analog ports
    // byte* emittingPointer = &animation[frame][0];
    OUTPUT_WAVE(emittingPointer, 0); buttonsPort = PIND; WAIT_LIT();

    OUTPUT_WAVE(emittingPointer, 1); anyButtonPressed = (buttonsPort & 0b11111100) != 0b11111100; WAIT_MID();
    OUTPUT_WAVE(emittingPointer, 2); buttonPressed[0] = buttonsPort & 0b00000100; WAIT_MID(); // PB2 pressed (D2, Up shift)
    OUTPUT_WAVE(emittingPointer, 3); buttonPressed[1] = buttonsPort & 0b00001000; WAIT_MID(); // PB3 pressed (D3, Down shift)
    OUTPUT_WAVE(emittingPointer, 4); buttonPressed[2] = buttonsPort & 0b00010000; WAIT_MID(); // PB4 pressed (D4, Reset)
    OUTPUT_WAVE(emittingPointer, 5); buttonPressed[3] = buttonsPort & 0b00100000; WAIT_MID(); // empty switch for wifi
    OUTPUT_WAVE(emittingPointer, 6); buttonPressed[4] = buttonsPort & 0b01000000; WAIT_MID(); // empty switch for wifi
    OUTPUT_WAVE(emittingPointer, 7); buttonPressed[5] = buttonsPort & 0b10000000; WAIT_MID(); // empty switch for wifi

    OUTPUT_WAVE(emittingPointer, 8); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 9); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 10); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 11); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 12); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 13); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 14); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 15); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 16); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 17); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 18); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 19); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 20); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 21); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 22); WAIT_LOT();
    OUTPUT_WAVE(emittingPointer, 23); 


    if( anyButtonPressed ){
      ++buttonCounter; // button counter count up
      
      // This is sensitivity of push button. If Button_SENS = 10000 <=> push 0.5s is real push.
      if (buttonCounter > BUTTON_SENS){
        buttonCounter = 0;
      
        // Up shift button pressed (D2)
        if (! buttonPressed[0] ) { --frame; }

        // Down shift button pressed (D3)
        else if (! buttonPressed[1] ) { ++frame; }

        // Reset button pressed (D4)
        else if (! buttonPressed[2] ) { frame = 19; }

        // Frame Overflow with up shift
        // It should be stop at final value, but it keeps going the phase shift until the start phase. Loop shifting
        // Just push the switch only 19. Not above.
        if( frame < 0 ) { frame = 0;}

        // Frame Overflow with down shift
        // When frame approach at 29, stop the phase shift
        else if ( frame >= N_FRAMES ) { frame = N_FRAMES-1;}

        // static byte frame = 19; (Start frame is 19th)
        // If any button pressed, frame number changes(up, down or reset)
        emittingPointer = & animation[frame][0];

      } // buttonCounter if code end
    
    } // anybuttonpressed if code end
    
    else {
    buttonCounter = 0;
    }
    
  goto LOOP; // LOOP end and go back
  
} // void setup end

void loop(){
  // empty loop 
}